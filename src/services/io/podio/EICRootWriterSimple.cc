
#include "EICRootWriterSimple.h"
#include <JANA/JLogger.h>

#include <datamodel_glue.h>

//------------------------------------------------------------------------------
// DeriveCollectionName
//
/// Derive a name for the podio collection based on the edm4hep data type
/// and the factory data type and tag.
///
/// This is a bit of guesswork. It must handle 2 different scenarios:
///
/// 1. Objects in the factory came straight from the podio input file which
/// means they have a type from edm4hep and a factory tag with the collection
/// name.
///
/// 2. Objects are of specialized classes that inherit from an edm4hep type
/// and their collection name should be the derived type's class name.
///
/// For option 2. the factory tag could represent either an alternative
/// algorithm or a special category. For example, a factory producing
/// BEMCRawCalorimeterHit objects may have a factory tag like
/// "DaveTest" to indicate it is an alternative version of the algorithm
/// that the user may select at run time. In this case, we would want the
/// objects to be placed in the store in the standard place without any
/// reference to "DaveTest" in the name. Alternatively, the factory may
/// have a tag like "inner" indicating it holds a subset of the objects
/// so the tag really represents a category of the data. In this case we
/// may want to write to a collection name that includes this tag.
///
/// For now, we simply look to see if the data type for the factory
/// is the same as that for the edm4hep type. If they are the same, then
/// use the factory tag as the collection name. If not, use the factory's
/// data type as the name. If the tag is empty, always use the factory's
/// data type as the name.
///
/// \param edm4hep_name
/// \param fac
/// \return
//------------------------------------------------------------------------------
template< typename T>
std::string DeriveCollectionName( const std::string &edm4hep_name,  JFactory *fac ){

    // TODO: Should the factory store the collection name as a special metadata field?
    if( fac->GetTag().empty() ) return fac->GetObjectName();
    if( std::type_index( typeid(T) ) == fac->GetObjectType()){
        return fac->GetTag();
    }else{
        return fac->GetObjectName();
    }
}

//------------------------------------------------------------------------------
// PutPODIODataT
//
/// This templated global routine is used to copy objects from a JANA factory
/// into the EICEventStore so they can later be written to the output file.
///
/// This gets called from the PutPODIOData routine defined in the datamodel_glue.h
/// file which is generated by the make_datamodel_glue.py script.
///
/// The "OutputType" class is the edm4hep object type, while the "C" class is the collection type
/// that holds it. (e.g. OutputType=SimTrackerHit, C=SimTrackerHitCollection )
///
/// The return value is the collection name created by DeriveCollectionName() above.
///
/// \tparam T      data class type (e.g. edm4hep::Cluster)
/// \tparam C      collection type (e.g. edm4hep::ClusterCollection)
/// \param fac     JANA factory holding objects of type OutputType
/// \param store   EICEventStore to copy the collection to
/// \return        derived name of the collection
//------------------------------------------------------------------------------
template <class T, class C>
std::string EICRootWriterSimple::PutPODIODataT( JFactory *fac,  podio::EventStore &store){

    // Formulate appropriate collection name based on edm4hep data type name and factory data type and tag.
    C tmp;
    const std::string &className = tmp.getValueTypeName();
    std::string collection_name = DeriveCollectionName<T>( className,  fac );

    // Check if a collection with this name already exists. If not, create one
    const C *collection = nullptr;
    if( !store.get(collection_name, collection)){

        // FIXME: This causes seg. faults
//        auto& mutable_collection = store.create<C>(collection_name);
//        m_writer->registerForWrite( collection_name );
//
//        // Copy objects into collection
//        auto tobjs = fac->GetAs<T>();
//        for( auto t : tobjs ){
//            mutable_collection->push_back( t->clone() );
//        }
    }

    return collection_name;
}

// ---------------------------------------------------------------------
// constructor
//
EICRootWriterSimple::EICRootWriterSimple() {
    SetTypeName(NAME_OF_THIS); // Provide JANA with this class's name

    japp->SetDefaultParameter(
            "podio:output_file",
            m_output_file,
            "Name of EDM4hep/podio output file to write to. Setting this will cause the output file to be created and written to."
            );

    // Allow user to set PODIO:OUTPUT_FILE to "1" to specify using the default name.
    if( m_output_file == "1" ){
        auto param = japp->GetJParameterManager()->FindParameter("podio:output_file" );
        if(param) {
            param->SetValue( param->GetDefault() );
            m_output_file = param->GetDefault();
        }
    }

    // Get the output directory path for creating a second copy of the output file at the end of processing.
    // (this is duplicating similar functionality in Juggler/Gaudi so assume it is useful).
    japp->SetDefaultParameter(
            "podio:output_file_copy_dir",
            m_output_file_copy_dir,
            "Directory name to make an additional copy of the output file to. Copy will be done at end of processing. Default is empty string which means do not make a copy. No check is made on path existing."
            );

    // Get the list of output collections to include/exclude
    std::vector<std::string> output_include_collections;  // need to get as vector, then convert to set
    std::vector<std::string> output_exclude_collections;  // need to get as vector, then convert to set
    japp->SetDefaultParameter(
            "podio:output_include_collections",
            output_include_collections,
            "Comma separated list of collection names to write out. If not set, all collections will be written (including ones from input file). Don't set this and use PODIO:OUTPUT_EXCLUDE_COLLECTIONS to write everything except a selection."
    );
    japp->SetDefaultParameter(
            "podio:output_exclude_collections",
            output_exclude_collections,
            "Comma separated list of collection names to not write out."
            );
    m_output_include_collections = std::set<std::string>(output_include_collections.begin(),
                                                         output_include_collections.end());
    m_output_exclude_collections = std::set<std::string>(output_exclude_collections.begin(),
                                                         output_exclude_collections.end());

}

void EICRootWriterSimple::Init() {
}

void EICRootWriterSimple::Process(const std::shared_ptr<const JEvent> &event) {

    // For now, we rely on the EventStore object having been created by the source and added to the event.
    // Copy it to a stack variable first so we can ensure it is the same EventStore object we use for
    // every event. This is because once the ROOTWriter is created below, we cannot change the EventStore
    // pointer it uses.
    auto store = event->GetSingle<podio::EventStore>();
    if( ! m_store ) m_store = const_cast<podio::EventStore*>(store);
    if( m_store != store ){
        LOG_ERROR(default_cerr_logger) << "podio::EventStore pointer has changed!" << LOG_END;
        LOG_ERROR(default_cerr_logger) << "This podio writer requires that the same EventStore object be used" << LOG_END;
        LOG_ERROR(default_cerr_logger) << "for every event. The one obtained from JANA for this event appears" << LOG_END;
        LOG_ERROR(default_cerr_logger) << "to be different from the previous event (" << store << " != " << m_store << LOG_END;
        throw JException("podio::EventStore pointer has changed between JANA events");
    }

    // Create podio::ROOTWriter object if not already created
    // We must do this here because we don't have the EventStore in Init()
    if(m_writer == nullptr ){
        // TODO: Check for error
        m_writer = std::make_shared<podio::ROOTWriter>(m_output_file, m_store);

        // Get list of collection names
        auto collectionIDtable = m_store->getCollectionIDTable();
        auto &collNames = collectionIDtable->names();
        std::set<std::string> collNames_set(collNames.begin(), collNames.end());

        // Determine what to include from include list (or include all if empty)
        if( m_output_include_collections.empty() ){
            m_collections_to_write = collNames_set; // user didn't specify. Assume all collections should be included
        }else{
            for( const auto &n : m_output_include_collections ){
                if( collNames_set.count( n ) ) m_collections_to_write.insert(n);
            }
        }

        // Determine which to exclude from exclude list
        for( const auto &n : m_output_exclude_collections ) m_collections_to_write.erase( n );

        // Apply include/exclude lists.
        for( const auto &collName : m_collections_to_write ) m_writer->registerForWrite( collName );
    }

    // Look for objects created by JANA, but not part of a collection in the EventStore and add them
    // Loop over all factories.
    for( auto fac : event->GetAllFactories() ){

        // Attempt to put data from all factories that have objects into the
        // store. This is called even for ones whose data classes don't inherit from
        // an edm4hep class. Those cases just silently do nothing here and return
        // an empty string. Note that this relies on the JFactory::EnableAs mechanism
        // so that needs to have been called in the factory constructor.
        if( fac->GetNumObjects() != 0 ){
            try {
                auto collection_name = PutPODIODataSimple(this, fac, *m_store);
            }catch(std::exception &e){
                LOG_ERROR(default_cerr_logger) << e.what() << " : " << fac->GetObjectName() << LOG_END;
            }

        }
    }

    m_writer->writeEvent();
    // n.b. we don't call clearCollections() here so we can leave that to the event source which owns the EventStore.

}

void EICRootWriterSimple::Finish() {

    m_writer->finish();
}

