// Copyright 2022, David Lawrence
// Subject to the terms in the LICENSE file found in the top-level directory.
//
//

#include <sstream>

#include "EDM4hepWriter.h"
#include <JANA/JLogger.h>

// This file is generated automatically by make_datamodel_glue.py
#include "datamodel_glue.h"

thread_local podio::EventStore EDM4hepWriter::m_store; // allow manipulations of EventStore to occur in parallel

//------------------------------------------------------------------------------
// DeriveCollectionName
//
/// Derive a name for the podio collection based on the edm4hep data type
/// and the factory data type and tag.
///
/// This is a bit of guesswork. It must handle 2 different scenarios:
///
/// 1. Objects in the factory came straight from the podio input file which
/// means they have a type from edm4hep and a factory tag with the collection
/// name.
///
/// 2. Objects are of specialized classes that inherit from an edm4hep type
/// and their collection name should be the derived type's class name.
///
/// For option 2. the factory tag could represent either an alternative
/// algorithm or a special category. For example, a factory producing
/// EMCalBarrelRawCalorimeterHit objects may have a factory tag like
/// "DaveTest" to indicate it is an alternative version of the algorithm
/// that the user may select at run time. In this case, we would want the
/// objects to be placed in the store in the standard place without any
/// reference to "DaveTest" in the name. Alternatively, the factory may
/// have a tag like "inner" indicating it holds a subset of the objects
/// so the tag really represents a category of the data. In this case we
/// may want to write to a collection name that includes this tag.
///
/// For now, we simply look to see if the data type for the factory
/// is the same as that for the edm4hep type. If they are the same, then
/// use the factory tag as the collection name. If not, use the factory's
/// data type as the name. If the tag is empty, always use the factory's
/// data type as the name.
///
/// \param edm4hep_name
/// \param fac
/// \return
//------------------------------------------------------------------------------
template< typename T>
std::string DeriveCollectionName( const std::string &edm4hep_name,  JFactory *fac ){

    // TODO: Should the factory store the collection name as a special metadata field?
    if( fac->GetTag() == "" ) return fac->GetObjectName();
    if( std::type_index( typeid(T) ) == fac->GetObjectType()){
        return fac->GetTag();
    }else{
        return fac->GetObjectName();
    }
}

//------------------------------------------------------------------------------
// PutPODIODataT
//
/// This templated global routine is used to copy objects from a JANA factory
/// into the podio store for the output file.
///
/// The return value is the collection name.
///
/// The "T" class is the edm4hep object type, while the "C" class is the collection type
/// that holds it. (e.g. T=SimTrackerHit, C=SimTrackerHitCollection )
///
/// This gets called from the PutPODIOData routine defined in the datamodel_glue.h
/// file which is generated by the make_datamodel_glue.py script.
///
/// \tparam T      data class type (e.g. edm4hep::Cluster)
/// \tparam C      collection type (e.g. edm4hep::ClusterCollection)
/// \param fac     JANA factory holding objects of type T
/// \param store   podio::EventStore to copy the collection to
/// \return        derived name of the collection
//------------------------------------------------------------------------------
template <class T, class C>
std::string PutPODIODataT( JFactory *fac, podio::EventStore &store, const std::set<std::string> &include_collections, const std::set<std::string> &exclude_collections){

    // Formulate appropriate collection name based on edm4hep data type name and factory data type and tag.
    C tmp;  // The getValueTypeName() method should be made static in the collection class.
    std::string collection_name = DeriveCollectionName<T>( tmp.getValueTypeName(),  fac );

    // Bail early if this is a collection the user indicated should be excluded.
    if( exclude_collections.count( collection_name ) ) return "";

    // Bail early if this is not a collection the user indicated should be included.
    if( (!include_collections.empty()) && (include_collections.count(collection_name)==0) ) return "";

    // Check if a collection with this name already exists in the store. If so, then
    // use it. If not, then create one and register it.
    // n.b. This is a very ugly pattern where we have to use a tmeporary pointer and and
    // const_cast to get at the existing collection. Nearly as bad, when creating a new
    // collection, it is returned by reference and we have to set a pointer to it just before
    // the reference variable falls out of scope.
    C* collection=nullptr;
    const C* tmpPtr = nullptr;
    if( store.get<C>(collection_name, tmpPtr) ) {
        collection = const_cast<C*>(tmpPtr);
    }else{
        auto &c = store.create<C>( collection_name );
        collection = &c;
    }

    // Get data objects from JANA and copy into collection.
    // Note here that obj is a pointer to an object of one of the edm4hep data types. This
    // is actually a wrapper of the actual data object so when we pass by value as *obj,
    // the wrapper is what is copied, not the underlying data. podio is responsible for tracking
    // the reference counters and managing those objects.
    auto v = fac->GetAs<T>();
//    _DBG_<<"--- cloning " << v.size() << " objects for " <<collection_name << std::endl;
    for( auto obj : v ) {
        auto obj_copy = obj->clone();
        collection->push_back( obj_copy );
    }

    return collection_name;
}


//------------------------------------------------------------------------------
// Constructor
//------------------------------------------------------------------------------
EDM4hepWriter::EDM4hepWriter() {
    SetTypeName(NAME_OF_THIS); // Provide JANA with this class's name
}

//------------------------------------------------------------------------------
// Init
//
/// Initialize by opening the output file and creating the TTree objects.
///
/// This is partially copied from here:
///
///   https://eicweb.phy.anl.gov/EIC/juggler/-/blob/master/JugBase/src/components/PodioOutput.cpp
///
//------------------------------------------------------------------------------
void EDM4hepWriter::Init() {
    // Get the output file name
    japp->SetDefaultParameter("PODIO:OUTPUT_FILE", m_OUTPUT_FILE, "Name of EDM4hep/podio output file to write to. Setting this will cause the output file to be created and written to.");

    // Allow user to set PODIO:OUTPUT_FILE to "1" to specify using the default name.
    if( m_OUTPUT_FILE == "1" ){
        auto param = japp->GetJParameterManager()->FindParameter("PODIO:OUTPUT_FILE" );
        if(param) {
            param->SetValue( param->GetDefault() );
            m_OUTPUT_FILE = param->GetDefault();
        }
    }

    // Get the output directory path for creating a second copy of the output file at the end of processing.
    // (this is duplicating similar functionality in Juggler/Gaudi so assume it is useful).
    japp->SetDefaultParameter("PODIO:OUTPUT_FILE_COPY_DIR", m_OUTPUT_FILE_COPY_DIR, "Directory name to make an additional copy of the output file to. Copy will be done at end of processing. Default is empty string which means do not make a copy. No check is made on path existing.");

    // Get the list of output collections to include
    // TODO: Convert this to using JANA support of array values in config parameters once it is available.
    japp->SetDefaultParameter("PODIO:OUTPUT_INCLUDE_COLLECTIONS", m_include_collections_str, "Comma separated list of collection names to write out. If not set, all collections will be written (including ones from input file). Don't set this and use PODIO:OUTPUT_EXCLUDE_COLLECTIONS to write everything except a selection.");
    if( ! m_include_collections_str.empty() ) {
        std::stringstream ss(m_include_collections_str);
        while (ss.good()) {
            std::string substr;
            getline(ss, substr, ',');
            m_OUTPUT_INCLUDE_COLLECTIONS.insert(substr);
        }
    }

    // Get the list of output collections to exclude
    // TODO: Convert this to using JANA support of array values in config parameters once it is available.
    japp->SetDefaultParameter("PODIO:OUTPUT_EXCLUDE_COLLECTIONS", m_exclude_collections_str, "Comma separated list of collection names to not write out.");
    if( ! m_exclude_collections_str.empty() ) {
        std::stringstream ss(m_exclude_collections_str);
        while (ss.good()) {
            std::string substr;
            getline(ss, substr, ',');
            m_OUTPUT_EXCLUDE_COLLECTIONS.insert(substr);
        }
    }

    // Open output file
    m_file = std::unique_ptr<TFile>(TFile::Open(m_OUTPUT_FILE.c_str(), "RECREATE", "data file"));

    // Create trees
    m_datatree     = new TTree("events",       "Events tree");
    m_metadatatree = new TTree("metadata",     "Metadata tree");
    m_runMDtree    = new TTree("run_metadata", "Run metadata tree");
    m_evtMDtree    = new TTree("evt_metadata", "Event metadata tree");
    m_colMDtree    = new TTree("col_metadata", "Collection metadata tree");

    m_evtMDtree->Branch("evtMD", "GenericParameters", m_store.eventMetaDataPtr() ) ;
}

//------------------------------------------------------------------------------
// createBranch
///
/// Create the appropriate branches in the events TTree to hold the given collection.
///
/// This is largely copied from here:
///
///   https://eicweb.phy.anl.gov/EIC/juggler/-/blob/master/JugBase/src/components/PodioOutput.cpp
///
/// \param collName Name of collection
/// \param collBase Pointer to collection
//------------------------------------------------------------------------------
void EDM4hepWriter::createBranch(const std::string& collName, podio::CollectionBase* collBase) {

    // Do not create branch(es) twice
    if( m_collections_map.count(collName) ) {
        LOG_ERROR( default_cerr_logger ) << "Attempting to create TBranch for collection " << collName << " when it already exists!" << LOG_END;
        return;
    }
    m_collections_map[ collName ] = collBase;

    auto buffers = collBase->getBuffers();
    auto* data = buffers.data;
    auto* references = buffers.references;
    auto* vecmembers = buffers.vectorMembers;

    const std::string className     = collBase->getValueTypeName();
    const std::string collClassName = "vector<" + className + "Data>";

    //LOG << "Creating branch for collection " << collName.c_str() << " of type " << className << LOG_END;

    auto branch = m_datatree->Branch(collName.c_str(), collClassName.c_str(), data);
    // Create branches for collections holding relations
    if (auto* refColls = references) {
        int j = 0;
        for (auto& c : (*refColls)) {
            const auto brName = refBranch(collName, j);
            m_datatree->Branch(brName.c_str(), c.get());
            ++j;
        }
    }
    // vector members
    if (auto* vminfo = vecmembers) {
        int j = 0;
        for (auto& [dataType, add] : (*vminfo)) {
            const std::string typeName = "vector<" + dataType + ">";
            const auto brName          = vecBranch(collName, j);
            m_datatree->Branch(brName.c_str(), typeName.c_str(), add);
            ++j;
        }
    }

    const auto collID = m_store.getCollectionIDTable()->collectionID(collName);
    const auto collType = collBase->getValueTypeName() + "Collection";
    const auto collInfo = std::tuple<int, std::string, bool>(collID, collType, collBase->isSubsetCollection());
    m_collectionInfo.push_back(collInfo);

    // Backfill for events we've missed.
    // This branch may not be created until some events have already been processed. In order to align
    // future events, we need to insert empty events for this branch. To do this, we need a data pointer
    // that points to an empty vector (data currently points to a vector, but one that is not empty).
    // Ideally we would make a std:vector of the correct type here, but that is a little difficult and
    // adds extra overhead. Instead, we make a temporary std::vector<uint64_t> with the assumption that
    // the root will see it has zero elements and do the correct thing.
    std::vector<uint64_t> tmpv;
    branch->SetAddress((void*)&tmpv);
    auto Nentries = m_datatree->GetEntries();
    //LOG << "Backfilling " << Nentries << " entries for branch " << collName << LOG_END;
    for( size_t i=0; i< Nentries; i++ ) branch->Fill();
}

//------------------------------------------------------------------------------
// resetBranches
//
/// Reset TTree branch addresses for all specified collections. This ensures
/// all branches are pointing to the correct memory locations since they
/// may have changed since the last event.
///
/// This is largely copied from here:
///
///   https://eicweb.phy.anl.gov/EIC/juggler/-/blob/master/JugBase/src/components/PodioOutput.cpp
///
/// \param collections
//------------------------------------------------------------------------------
void EDM4hepWriter::resetBranches(const std::map<std::string, podio::CollectionBase*>& collections) {
    for (const auto& [collName, collBuffers] : collections) {

        // This copies all of the POD structures into the internally managed std::vector
        // objects that will be returned by the getBuffers() call below.
        collBuffers->prepareForWrite();

        auto buffers = collBuffers->getBuffers();
        auto* data = buffers.data;
        auto* references = buffers.references;
        auto* vecmembers = buffers.vectorMembers;

        // Reconnect branches and collections
        m_datatree->SetBranchAddress(collName.c_str(), data);
        auto* colls = references;
        if (colls != nullptr) {
            for (size_t j = 0; j < colls->size(); ++j) {
                const auto brName = refBranch(collName, j);
                auto* l_branch = m_datatree->GetBranch(brName.c_str());
                l_branch->SetAddress(&(*colls)[j]);
            }
        }
        auto* colls_v = vecmembers;
        if (colls_v != nullptr) {
            int j = 0;
            for (auto& [dataType, add] : (*colls_v)) {
                const auto brName = vecBranch(collName, j);
                m_datatree->SetBranchAddress(brName.c_str(), add);
                ++j;
            }
        }
    }
}

//------------------------------------------------------------------------------
// Process
//
/// Process single event, writing it to the TTrees in the root file.
/// This will write out all objects already in the factories, it
/// currently does not activate any factory algorithms to generate
/// objects. Thus, this should be at the end of any plugin list.
///
/// TODO: This should automatically activate factories corresponding
/// TODO: to the collections specified for writing out.
///
/// \param event
//------------------------------------------------------------------------------
void EDM4hepWriter::Process(const std::shared_ptr<const JEvent> &event) {

    // Empty all collections to prepare for writing this event
    m_store.clearCollections();

    for( auto fac : event->GetAllFactories() ){

        // Attempt to put data from all factories that have objects into the output
        // store. This is called even for ones whose data classes don't inherit from
        // an edm4hep class. Those cases just silently do nothing here and return
        // an empty string.
        if( fac->GetNumObjects() != 0 ){
            try {
                auto collection_name = PutPODIOData(fac, m_store, m_OUTPUT_INCLUDE_COLLECTIONS, m_OUTPUT_EXCLUDE_COLLECTIONS);
            }catch(std::exception &e){
                std::cerr << e.what() << " : " << fac->GetObjectName() << std::endl;
            }

        }
     }

    // Lock mutex
    // We take advantage of m_store being thread_local above to allow multiple ones to be
    // filled simultaneously. At this point though we need to modify the ROOT trees so
    // need to fall back into sequential mode.
    // TODO: This needs to be changed to use the global ROOT write lock.
    std::lock_guard<std::mutex>lock(m_mutex);

    // Create branches in the data tree for any collections that we have not already created a branch for.
    auto collTable = m_store.getCollectionIDTable();
    for( auto id : collTable->ids() ){
        podio::CollectionBase *coll;
        if( m_store.get(id, coll) ) {
            const auto &collName = collTable->name( id );
            if( m_OUTPUT_EXCLUDE_COLLECTIONS.count(collName) ) continue; // ignore collections in exclude list
            if( m_OUTPUT_INCLUDE_COLLECTIONS.empty() || m_OUTPUT_INCLUDE_COLLECTIONS.count(collName)) {
                // Create the branch if we have not already done so.
                if( ! m_collections_map.count(collName)  ) createBranch( collName, coll );
            }
        }
    }

    // Reset the branch addresses for all collections we are writing and prepare them for writing
    resetBranches( m_collections_map );

    // Write the event to trees
    if( m_datatree  ) m_datatree->Fill();
    if( m_evtMDtree ) m_evtMDtree->Fill();

}

//------------------------------------------------------------------------------
// Finish
//
/// Called once automatically by JANA at end of job. Flushes trees and closes
/// output files.
///
/// TODO: Add JANA configuration parameters as metadata to file.
//------------------------------------------------------------------------------
void EDM4hepWriter::Finish() {

    LOG << "Finalizing trees and output file" << LOG_END;
    m_file->cd();
    //m_metadatatree->Branch("gaudiConfigOptions", &config_data);
    // TODO: Copy all JANA configuration parameters into the metadata tree.
    // TODO: This will be most easily done when JANA issue #120 is resolved
    // TODO: so we can easily access the full list.

    m_metadatatree->Branch("CollectionTypeInfo", &m_collectionInfo);
    m_metadatatree->Branch("CollectionIDs", m_store.getCollectionIDTable());
    m_metadatatree->Fill();
    m_colMDtree->Branch("colMD", "std::map<int,podio::GenericParameters>", m_store.getColMetaDataMap() ) ;
    m_colMDtree->Fill();
    m_runMDtree->Branch("runMD", "std::map<int,podio::GenericParameters>", m_store.getRunMetaDataMap() ) ;
    m_runMDtree->Fill();
    m_datatree->Write();
    m_file->Write();
    m_file->Close();
    m_datatree = nullptr;
    m_evtMDtree = nullptr;
    LOG << "Data written to: " << m_OUTPUT_FILE << LOG_END;

    // Optionally copy file to a second location.
    // This is just duplicating what was done in the Juggler/Gaudi implementation.
    if (!m_OUTPUT_FILE_COPY_DIR.empty()) {
        TFile::Cp(m_OUTPUT_FILE.c_str(), m_OUTPUT_FILE_COPY_DIR.c_str(), false);
        LOG << " and copied to: " << m_OUTPUT_FILE_COPY_DIR << LOG_END;
    }

}
