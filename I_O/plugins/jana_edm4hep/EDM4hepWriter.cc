// Copyright 2022, David Lawrence
// Subject to the terms in the LICENSE file found in the top-level directory.
//
//

#include <sstream>

#include "EDM4hepWriter.h"
#include <JANA/JLogger.h>

// This file is generated automatically by make_datamodel_glue.py
#include "datamodel_glue.h"


//------------------------------------------------------------------------------
// PutPODIODataT
//
/// Derive a name for the podio collection based on the edm4hep data type
/// and the factory data type and tag.
///
/// This is a bit of guesswork. It must handle 2 different scenarios:
///
/// 1. Objects in the factory came straight from the podio input file which
/// means they have a type from edm4hep and a factory tag with the collection
/// name.
///
/// 2. Objects are of specialized classes that inherit from an edm4hep type
/// and their collection name should be the derived type's class name.
///
/// For option 2. the factory tag could represent either an alternative
/// algorithm or a special category. For example, a factory producing
/// EMCalBarrelRawCalorimeterHit objects may have a factory tag like
/// "DaveTest" to indicate it is an alternative version of the algorithm
/// that the user may select at run time. In this case, we would want the
/// objects to be placed in the store in the standard place without any
/// reference to "DaveTest" in the name. Alternatively, the factory may
/// have a tag like "inner" indicating it holds a subset of the objects
/// so the tag really represents a category of the data. In this case we
/// may want to write to a collection name that includes this tag.
///
/// For now, we simply look to see if the data type for the factory
/// is that same as that for the edm4hep type. If they are the same, then
/// use the factory tag as the collection name. If not, use the factory's
/// data type as the name. If the tag is empty, always use the factory's
/// data type as the name.
///
/// \param edm4hep_name
/// \param fac
/// \return
//------------------------------------------------------------------------------
template< typename T>
std::string DeriveCollectionName( const std::string &edm4hep_name,  JFactory *fac ){

    // TODO: Should the factory store the collection name as a special metadata field?
    if( fac->GetTag() == "" ) return fac->GetObjectName();
    if( std::type_index( typeid(T) ) == fac->GetObjectType()){
        return fac->GetTag();
    }else{
        return fac->GetObjectName();
    }
}

//------------------------------------------------------------------------------
// PutPODIODataT
//
/// This templated global routine is used to copy objects from a JANA factory
/// into the podio store for the output file.
///
/// The "T" class is the edm4hep object type, while the "C" class is the collection type
/// that holds it. (e.g. T=SimTrackerHit, C=SimTrackerHitCollection )
///
/// This gets called from the PutPODIOData routine defined in the datamodel_glue.h
/// file which is generated by the make_datamodel_glue.py script.
//------------------------------------------------------------------------------
template <class T, class C>
void PutPODIODataT( JFactory *fac, podio::EventStore &store){

    // Create empty collection of appropriate edm4hep type
    C* collection = new C();

    // Formulate appropriate collection name based on edm4hep data type name and factory data type and tag.
    std::string collection_name = DeriveCollectionName<T>( collection->getValueTypeName(),  fac );

    // Get data objects from JANA and copy into collection.
    // Note here that obj is a pointer to an object of one of the edm4hep data types. This
    // is actually a wrapper of the actual data object so when we pass by value as *obj,
    // the wrapper is what is copied, not the underlying data. podio is responsible for tracking
    // the reference counters and managing those objects.
    auto v = fac->GetAs<T>();
    for( auto obj : v ) collection->push_back( *obj );

    // Register the collection with the event store.
    // Note that this passes ownership of the collection over to the store which should delete it
    // and all of its contents when store.clear() is called.
    store.registerCollection( collection_name, collection );
}


//------------------------------------------------------------------------------
// Constructor
//------------------------------------------------------------------------------
EDM4hepWriter::EDM4hepWriter() {
    SetTypeName(NAME_OF_THIS); // Provide JANA with this class's name
}

//------------------------------------------------------------------------------
// Init
//------------------------------------------------------------------------------
void EDM4hepWriter::Init() {

    // Get the output file name
    japp->SetDefaultParameter("PODIO:OUTPUT_FILE", m_OUTPUT_FILE, "Name of EDM4hep/podio output file to write to. Setting this will cause the output file to be created and written to.");

    // Allow user to set PODIO:OUTPUT_FILE to "1" to specify using the default name.
    if( m_OUTPUT_FILE == "1" ){
        auto param = japp->GetJParameterManager()->FindParameter("PODIO:OUTPUT_FILE" );
        if(param) param->SetValue( param->GetDefault() );
    }

    // Get the list of output collections
    // n.b. defer checking these against what's available until OpenOutputFile() is called
    // TODO: Convert this to using JANA support of array values in config parameters once it is available.
    japp->SetDefaultParameter("PODIO:OUTPUT_COLLECTION_NAMES", m_collection_names_str, "Comma separated list of collection names to write out. If not set, all collections will be written (including ones from input file).");
    if( ! m_collection_names_str.empty() ) {
        std::stringstream ss(m_collection_names_str);
        while (ss.good()) {
            std::string substr;
            getline(ss, substr, ',');
            m_OUTPUT_COLLECTIONS.push_back(substr);
        }
    }
}

//------------------------------------------------------------------------------
// Process
//------------------------------------------------------------------------------
void EDM4hepWriter::Process(const std::shared_ptr<const JEvent> &event) {

    // Lock mutex
    // TODO: The EventStore class in PODIO needs to be made thread safe and this
    // TODO: can then be upated to use that functionality. In the meantime,
    // TODO: ensure we access the store sequentially.
    std::lock_guard<std::mutex>lock(m_mutex);

    store.clear();

    for( auto fac : event->GetAllFactories() ){

        // Attempt to put data from all factories that have objects into the output
        // store. This is called even for ones whose data classes don't inherit from
        // an edm4hep class. Those cases just silently do nothing here.
        if( fac->GetNumObjects() != 0 ) PutPODIOData(fac, store);
     }
}

//------------------------------------------------------------------------------
// Finish
//------------------------------------------------------------------------------
void EDM4hepWriter::Finish() {
    // Close any resources
    LOG << "EDM4hepWriter::Finish" << LOG_END;
}

