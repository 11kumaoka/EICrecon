// Copyright 2022, David Lawrence
// Subject to the terms in the LICENSE file found in the top-level directory.
//
//

#include <sstream>

#include "EDM4hepWriter.h"
#include <JANA/JLogger.h>

// This file is generated automatically by make_datamodel_glue.py
#include "datamodel_glue.h"


//------------------------------------------------------------------------------
// PutPODIODataT
//
/// Derive a name for the podio collection based on the edm4hep data type
/// and the factory data type and tag.
///
/// This is a bit of guesswork. It must handle 2 different scenarios:
///
/// 1. Objects in the factory came straight from the podio input file which
/// means they have a type from edm4hep and a factory tag with the collection
/// name.
///
/// 2. Objects are of specialized classes that inherit from an edm4hep type
/// and their collection name should be the derived type's class name.
///
/// For option 2. the factory tag could represent either an alternative
/// algorithm or a special category. For example, a factory producing
/// EMCalBarrelRawCalorimeterHit objects may have a factory tag like
/// "DaveTest" to indicate it is an alternative version of the algorithm
/// that the user may select at run time. In this case, we would want the
/// objects to be placed in the store in the standard place without any
/// reference to "DaveTest" in the name. Alternatively, the factory may
/// have a tag like "inner" indicating it holds a subset of the objects
/// so the tag really represents a category of the data. In this case we
/// may want to write to a collection name that includes this tag.
///
/// For now, we simply look to see if the data type for the factory
/// is that same as that for the edm4hep type. If they are the same, then
/// use the factory tag as the collection name. If not, use the factory's
/// data type as the name. If the tag is empty, always use the factory's
/// data type as the name.
///
/// \param edm4hep_name
/// \param fac
/// \return
//------------------------------------------------------------------------------
template< typename T>
std::string DeriveCollectionName( const std::string &edm4hep_name,  JFactory *fac ){

    // TODO: Should the factory store the collection name as a special metadata field?
    if( fac->GetTag() == "" ) return fac->GetObjectName();
    if( std::type_index( typeid(T) ) == fac->GetObjectType()){
        return fac->GetTag();
    }else{
        return fac->GetObjectName();
    }
}

//------------------------------------------------------------------------------
// PutPODIODataT
//
/// This templated global routine is used to copy objects from a JANA factory
/// into the podio store for the output file.
///
/// The return value is the collection name.
///
/// The "T" class is the edm4hep object type, while the "C" class is the collection type
/// that holds it. (e.g. T=SimTrackerHit, C=SimTrackerHitCollection )
///
/// This gets called from the PutPODIOData routine defined in the datamodel_glue.h
/// file which is generated by the make_datamodel_glue.py script.
//------------------------------------------------------------------------------
template <class T, class C>
std::string PutPODIODataT( JFactory *fac, podio::EventStore &store){

    // Create empty collection of appropriate edm4hep type
    C* collection = new C();

    // Formulate appropriate collection name based on edm4hep data type name and factory data type and tag.
    std::string collection_name = DeriveCollectionName<T>( collection->getValueTypeName(),  fac );

    // Get data objects from JANA and copy into collection.
    // Note here that obj is a pointer to an object of one of the edm4hep data types. This
    // is actually a wrapper of the actual data object so when we pass by value as *obj,
    // the wrapper is what is copied, not the underlying data. podio is responsible for tracking
    // the reference counters and managing those objects.
    auto v = fac->GetAs<T>();
    for( auto obj : v ) {
        auto obj_copy = obj->clone();
        collection->push_back( obj_copy );
    }

    // Register the collection with the event store.
    // Note that this passes ownership of the collection over to the store which should delete it
    // and all of its contents when store.clear() is called.
    collection->prepareForWrite();
    store.registerCollection( collection_name, collection );

    return collection_name;
}


//------------------------------------------------------------------------------
// Constructor
//------------------------------------------------------------------------------
EDM4hepWriter::EDM4hepWriter() {
    SetTypeName(NAME_OF_THIS); // Provide JANA with this class's name
}

//------------------------------------------------------------------------------
// Init
//------------------------------------------------------------------------------
void EDM4hepWriter::Init() {
    // Get the output file name
    japp->SetDefaultParameter("PODIO:OUTPUT_FILE", m_OUTPUT_FILE, "Name of EDM4hep/podio output file to write to. Setting this will cause the output file to be created and written to.");

    // Allow user to set PODIO:OUTPUT_FILE to "1" to specify using the default name.
    if( m_OUTPUT_FILE == "1" ){
        auto param = japp->GetJParameterManager()->FindParameter("PODIO:OUTPUT_FILE" );
        if(param) param->SetValue( param->GetDefault() );
    }

    // Get the list of output collections
    // n.b. defer checking these against what's available until OpenOutputFile() is called
    // TODO: Convert this to using JANA support of array values in config parameters once it is available.
    japp->SetDefaultParameter("PODIO:OUTPUT_COLLECTION_NAMES", m_collection_names_str, "Comma separated list of collection names to write out. If not set, all collections will be written (including ones from input file).");
    if( ! m_collection_names_str.empty() ) {
        std::stringstream ss(m_collection_names_str);
        while (ss.good()) {
            std::string substr;
            getline(ss, substr, ',');
            m_OUTPUT_COLLECTIONS.insert(substr);
        }
    }

    // Open output file
    writer = std::make_unique<EDM4hepWriter::ROOTWriter>(m_OUTPUT_FILE, &store);
}

//------------------------------------------------------------------------------
// Process
//------------------------------------------------------------------------------
void EDM4hepWriter::Process(const std::shared_ptr<const JEvent> &event) {
    // Lock mutex
    // TODO: The EventStore class in PODIO needs to be made thread safe and this
    // TODO: can then be upated to use that functionality. In the meantime,
    // TODO: ensure we access the store sequentially.
    std::lock_guard<std::mutex>lock(m_mutex);

    store.clear();

    std::vector<std::string> collection_names;
    for( auto fac : event->GetAllFactories() ){

        // Attempt to put data from all factories that have objects into the output
        // store. This is called even for ones whose data classes don't inherit from
        // an edm4hep class. Those cases just silently do nothing here and return
        // an empty string.
        if( fac->GetNumObjects() != 0 ){
            try {
                auto collection_name = PutPODIOData(fac, store);
                if( ! collection_name.empty() ) collection_names.push_back( collection_name );
            }catch(std::exception &e){
                std::cerr << e.what() << " : " << fac->GetObjectName() << std::endl;
            }

        }
     }

    // Register which collections to write
    // TODO: This is more complicated than it needs to be since the bare-bones podio::ROOTWriter
    // TODO: class provides little in the way of managing the list of collections to write.
    // TODO: It also uses a vector to store the items rather than a set so there is no protection
    // TODO: against duplicate entries. Hence the need for m_registered_collections here.
    for( auto collection_name : collection_names ){
        if( m_registered_collections.count( collection_name ) ) continue; // already registered
        bool register_collection = m_OUTPUT_COLLECTIONS.empty() || (m_OUTPUT_COLLECTIONS.count(collection_name)!=0);
        if( register_collection ){
            writer->registerForWrite( collection_name );
            m_registered_collections.insert( collection_name );
        }
    }

    // Make sure a collection exists for each of the collections we specified to write
    // TODO: This is again, significantly complicated by the minimal ROOTWriter class that does not
    // TODO: properly check that a store.get() call succeeds before trying to use the pointer
    // TODO: it returns. It also lacks a way of removing collections from the list to write
    // TODO: once they are there. The only recourse aside from modifying the ROOTWriter class
    // TODO: itself seems to be ensuring the a collection exists

    // Write the event to the file
    writer->writeEvent();
}

//------------------------------------------------------------------------------
// Finish
//------------------------------------------------------------------------------
void EDM4hepWriter::Finish() {
    // Close any resources
    writer->finish();
}

//===================================================================================================================
// Code in this section copied from src/rootUtils.h in the podio source
// (oddly, does not seem to get installed?!)

inline std::string refBranch(const std::string& name, size_t index) {
    return name + "#" + std::to_string(index);
}

inline std::string vecBranch(const std::string& name, size_t index) {
    return name + "_" + std::to_string(index);
}

inline void setCollectionAddresses(podio::CollectionBase* collection, const EDM4hepWriter::CollectionBranches& branches) {
    const auto collBuffers = collection->getBuffers();

    if (auto buffer = collBuffers.data) {
        branches.data->SetAddress(buffer);
    }

    if (auto refCollections = collBuffers.references) {
        for (size_t i = 0; i < refCollections->size(); ++i) {
            branches.refs[i]->SetAddress(&(*refCollections)[i]);
        }
    }

    if (auto vecMembers = collBuffers.vectorMembers) {
        for (size_t i = 0; i < vecMembers->size(); ++i) {
            branches.vecs[i]->SetAddress((*vecMembers)[i].second);
        }
    }
}

// A collection of additional information that describes the collection: the
// collectionID, the collection (data) type, and whether it is a subset
// collection
using CollectionInfoT = std::tuple<int, std::string, bool>;
//===================================================================================================================

//===================================================================================================================
// Code below this line copied from the example ROOTWriter class in podio. It has been modified to
// fix numerous bugs and make it usable.
//
// TODO: Copy the changes back into the podio::ROOTWriter class and submit a PR so these are fixed upstream.

EDM4hepWriter::ROOTWriter::ROOTWriter(const std::string& filename, podio::EventStore* store) :
        m_filename(filename),
        m_store(store),
        m_file(new TFile(filename.c_str(),"RECREATE","data file")),
        m_datatree(new TTree("events","Events tree")),
        m_metadatatree(new TTree("metadata", "Metadata tree")),
        m_runMDtree(new TTree("run_metadata", "Run metadata tree")),
        m_evtMDtree(new TTree("evt_metadata", "Event metadata tree")),
        m_colMDtree(new TTree("col_metadata", "Collection metadata tree"))
{

    m_evtMDtree->Branch("evtMD", "GenericParameters", m_store->eventMetaDataPtr() ) ;
}

EDM4hepWriter::ROOTWriter::~ROOTWriter(){
    delete m_file;
}

void EDM4hepWriter::ROOTWriter::writeEvent(){
    std::vector<StoreCollection> collections;
    collections.reserve(m_collectionsToWrite.size());
    for (const auto& name : m_collectionsToWrite) {
        const podio::CollectionBase* coll;
        if( m_store->get(name, coll)){
            collections.emplace_back(name, const_cast<podio::CollectionBase*>(coll));
            collections.back().second->prepareForWrite();
        }
    }

    if (m_firstEvent) {
        createBranches(collections);
        m_firstEvent = false;
    } else {
        setBranches(collections);
    }

    m_datatree->Fill();
    m_evtMDtree->Fill();
}

void EDM4hepWriter::ROOTWriter::createBranches(const std::vector<StoreCollection>& collections) {
    for (auto& [name, coll] : collections) {
        EDM4hepWriter::CollectionBranches branches;
        const auto collBuffers = coll->getBuffers();
        if (collBuffers.data) {
            // only create the data buffer branch if necessary

            auto collClassName = "vector<" + coll->getDataTypeName() +">";

            branches.data = m_datatree->Branch(name.c_str(), collClassName.c_str(), collBuffers.data);
        }

        // reference collections
        if (auto refColls = collBuffers.references) {
            int i = 0;
            for (auto& c : (*refColls)) {
                const auto brName = ::refBranch(name, i);
                branches.refs.push_back(m_datatree->Branch(brName.c_str(), c.get()));
                ++i;
            }
        }

        // vector members
        if (auto vminfo = collBuffers.vectorMembers) {
            int i = 0;
            for (auto& [type, vec] : (*vminfo)) {
                const auto typeName = "vector<" + type + ">";
                const auto brName = ::vecBranch(name, i);
                branches.vecs.push_back(m_datatree->Branch(brName.c_str(), typeName.c_str(), vec));
                ++i;
            }
        }

        m_collectionBranches.push_back(branches);
    }
}

void EDM4hepWriter::ROOTWriter::setBranches(const std::vector<StoreCollection>& collections) {
    size_t iCollection = 0;
    for (auto& coll : collections) {
        const auto& branches = m_collectionBranches[iCollection];
        ::setCollectionAddresses(coll.second, branches);

        iCollection++;
    }
}


void EDM4hepWriter::ROOTWriter::finish(){
    // now we want to safe the metadata. This includes info about the
    // collections
    const auto collIDTable = m_store->getCollectionIDTable();
    m_metadatatree->Branch("CollectionIDs", collIDTable);

    // collectionID, collection type, subset collection
    std::vector<::CollectionInfoT> collectionInfo;
    collectionInfo.reserve(m_collectionsToWrite.size());
    for (const auto& name : m_collectionsToWrite) {
        const auto collID = collIDTable->collectionID(name);
        const podio::CollectionBase* coll{nullptr};
        // No check necessary, only registered collections possible
        m_store->get(name, coll);
        const auto collType = coll->getTypeName() ;
        collectionInfo.emplace_back(collID, std::move(collType), coll->isSubsetCollection());
    }

    m_metadatatree->Branch("CollectionTypeInfo", &collectionInfo);

    podio::version::Version podioVersion = podio::version::build_version;
    m_metadatatree->Branch("PodioVersion", &podioVersion);

    m_metadatatree->Fill();

    m_colMDtree->Branch("colMD", "std::map<int,podio::GenericParameters>", m_store->getColMetaDataMap() ) ;
    m_colMDtree->Fill();
    m_runMDtree->Branch("runMD", "std::map<int,podio::GenericParameters>", m_store->getRunMetaDataMap() ) ;
    m_runMDtree->Fill();

    m_file->Write();
    m_file->Close();
}


bool EDM4hepWriter::ROOTWriter::registerForWrite(const std::string& name) {
    const podio::CollectionBase* tmp_coll(nullptr);
    if (!m_store->get(name, tmp_coll)) {
        std::cerr << "no such collection to write, throw exception." << std::endl;
        return false;
    }

    m_collectionsToWrite.push_back(name);
    return true;
}
