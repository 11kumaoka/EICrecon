//
// This is a JANA event source that uses PODIO to read from a ROOT
// file created by the "test/write" program that comes with PODIO.
// It only reads 3 data types from the file, but puts those objects
// into the JANA event for use by the rest of the framework.
//
// n.b. JANA uses copies of const pointers to the objects PODIO owns
// so memory usage etc. is optimized.
//
// n.b. This is currently NOT thread safe. This is due to PODIO using
// TTree underneath so reading a second event in will overwrite the
// current one (and thus, invalidate the pointers). A deeper
// understanding of PODIO is needed to fix this.

#include "JEventSourcePODIO.h"

#include <JANA/JApplication.h>
#include <JANA/JEvent.h>
#include <filesystem>

// podio specific includes
#include "podio/EventStore.h"
#include "podio/IReader.h"
#include "podio/UserDataCollection.h"
#include "podio/podioVersion.h"

// This file is generated automatically by make_datamodel_glue.py
#include "datamodel_glue.h"

// Make this a JANA plugin
extern "C" {
void InitPlugin(JApplication *app) {
    InitJANAPlugin(app);
    app->Add(new JEventSourceGeneratorT<JEventSourcePODIO>());
}
}

//------------------------------------------------------------------------------
// GetPODIOData
//
/// This templated global routine used to easily add new data types to the
/// JEvent which are read from the PODIO store. Ownership is maintained
/// by PODIO.
/// The "T" class is the object type, while the "C" class is the collection type
/// that holds it.
///
/// This gets called from the datamodel_glue.h file which is generated by the
/// make_datamodel_glue.py script.
//------------------------------------------------------------------------------
template <class T, class C>
void GetPODIOData( const char *name, std::shared_ptr <JEvent> &event, podio::EventStore &store){
    std::vector<const T *> T_pointers;
    auto& Ts  = store.get<C>(name);
    if (Ts.isValid()) {
        for( const auto &t : Ts ){
            T_pointers.push_back( &t );
        }
    }

    // Insert the pointers into the JEvent. Set the NOT_OBJECT_OWNER flag so that
    // JANA will not try and delete these at the end of the event.
    if( !T_pointers.empty() ){
        auto fac = event->Insert(T_pointers);
        fac->SetFactoryFlag( JFactory::NOT_OBJECT_OWNER );
    }
}

//------------------------------------------------------------------------------
// Constructor
//------------------------------------------------------------------------------
JEventSourcePODIO::JEventSourcePODIO(std::string resource_name, JApplication* app) : JEventSource(resource_name, app) {
    SetTypeName(NAME_OF_THIS); // Provide JANA with class name
}

//------------------------------------------------------------------------------
// Open
//------------------------------------------------------------------------------
void JEventSourcePODIO::Open() {

    // Open is called exactly once when processing begins.
	
    // Allow user to specify to recycle events forever
    GetApplication()->SetDefaultParameter("PODIO:RUN_FOREVER", run_forever, "set to true to recycle through events continuously");

    try {
        // Have PODIO reader open file and get the number of events from it.
        std::string filename = GetResourceName();

        // TODO: Replace the example podio::ROOTReader with something that is thread safe
        // TODO: and does better error checking.
        if( ! std::filesystem::exists(filename) ){
            LOG_ERROR(default_cerr_logger) << LOG_END
            LOG_ERROR(default_cerr_logger) << "File \"" << filename << "\" does not exist!" << LOG_END;
            LOG_ERROR(default_cerr_logger) << LOG_END
            GetApplication()->Quit();
            return;
        }
        reader.openFile(filename);

        if( ! reader.isValid() ){
            LOG_ERROR(default_cerr_logger) << "podio::ROOTReader is invalid after attempting to open file." << LOG_END;
            GetApplication()->Quit();
            return;
        }
        if (reader.currentFileVersion() != podio::version::build_version) {
            LOG_ERROR(default_cerr_logger) << "Mismatch in PODIO versions! " << reader.currentFileVersion() << " != "
                  << podio::version::build_version << LOG_END;
            GetApplication()->Quit();
            return;
        }
        Nevents_in_file = reader.getEntries();
        jout << "Opened PODIO file \"" << filename << "\" with " << Nevents_in_file << " events" << std::endl;

        // Tell PODIO event store where to get its data from
        store.setReader(&reader);
    }catch (std::exception &e ){
        _DBG__;
        LOG_ERROR(default_cerr_logger) << "Problem opening file \"" << GetResourceName() << "\"" << LOG_END;
        LOG_ERROR(default_cerr_logger) << e.what() << LOG_END;
        GetApplication()->Quit();
        return;
    }
}

//------------------------------------------------------------------------------
// GetEvent
//------------------------------------------------------------------------------
void JEventSourcePODIO::GetEvent(std::shared_ptr <JEvent> event) {

    /// Calls to GetEvent are synchronized with each other, which means they can
    /// read and write state on the JEventSource without causing race conditions.
    
    // Check if we have exhausted events from file
    if( Nevents_read >= Nevents_in_file ) {
        if( run_forever ){
            Nevents_read = 0;
        }else{
            reader.closeFile();
            throw RETURN_STATUS::kNO_MORE_EVENTS;
        }
    }
	
    // This tells PODIO to free up the memory/caches used for the
    // collections and MetaData left from the last event.
    store.clear();
	
    // Tell PODIO which event to read into the store on the next calls to
    // getEventMetaData() and get<>() etc... below
    reader.goToEvent( Nevents_read++ );

    // For the example.root file generated in the PODIO example, there is one
    // meta data value for each type: string, float, int. These have names:
    // UserEventName, UserEventWeight, and SomeVectorData respectively.
    // We read it here for demonstration, but don't use it.
    const auto& evtMD = store.getEventMetaData();

    // We would normally want to obtain these from the metadata of the event/run
    event->SetEventNumber(Nevents_read);
    event->SetRunNumber(33);

    // The following reads the data for each of the collections into memory and
    // then copies the pointers into the JEvent so they can easily be used
    // by JANA algorithms. Ownership of the objects still resides with the
    // PODIO store. See the template definition in JEventSourcePODIO.h.
    GetAllPODIOData(event, store);
}

//------------------------------------------------------------------------------
// GetDescription
//------------------------------------------------------------------------------
std::string JEventSourcePODIO::GetDescription() {

    /// GetDescription() helps JANA explain to the user what is going on
    return "PODIO root file (example)";
}

//------------------------------------------------------------------------------
// CheckOpenable
//------------------------------------------------------------------------------
template <>
double JEventSourceGeneratorT<JEventSourcePODIO>::CheckOpenable(std::string resource_name) {

    // If source is a root file, given minimal probability of success so we're chosen
    // only if no other ROOT file sources exist.
    return (resource_name.find(".root") != std::string::npos ) ? 0.01 : 0.0;
}
