#!/usr/bin/env python

#
#  This is a stop gap and not intended for long term.  2022-07-09  DL
#
# This will scan the list of files in the datamodel directory and
# using the filenames generate some C++ code that can be used by
# the JEventSourcePODIO to read all of those types in.
#

import os
import sys
import glob

print('Generating datamodel_glue.h ,,,')

collectionfiles = glob.glob('datamodel/*Collection.h')
header_lines = []
code_lines = []
for f in collectionfiles:
    basename = f.split('/')[1].split('Collection.h')[0]
    header = '#include "' + f + '"'
    code1 = '    if( collection_type == "edm4hep::'+basename+'" )'
    code2 = '        {GetPODIODataT<'+basename+',  '+basename+'Collection>(collection_name.c_str(), event, store); return;}'
    header_lines += [header]
    code_lines += [code1, code2]

code_lines += ['    std::cerr << "Unknown collection type: " << collection_type << std::endl;']

with open('datamodel_glue.h', 'w') as f:
    f.write('\n// This file automatically generated by the make_datamodel.py script\n')
    f.write('\ntemplate <class T, class C> void GetPODIODataT( const char *collection_name, std::shared_ptr <JEvent> &event, podio::EventStore &store);\n\n')
    f.write('\n'.join(header_lines))
    f.write('\nusing namespace edm4hep;\n')
    f.write('\nstatic void GetPODIOData(const std::string &collection_name, const std::string &collection_type, std::shared_ptr <JEvent> &event, podio::EventStore &store){\n')
    f.write('\n'.join(code_lines))
    f.write('\n}\n')
    f.close()
